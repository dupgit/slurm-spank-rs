#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]
/* automatically generated by rust-bindgen 0.58.1 */


pub const HAVE_S_CTX_SLURMD: u32 = 1;
pub const HAVE_S_CTX_JOB_SCRIPT: u32 = 1;
pub const SPANK_OPTION_MAXLEN: u32 = 75;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spank_handle {
    _unused: [u8; 0],
}
pub type spank_t = *mut spank_handle;
pub type spank_f = ::std::option::Option<
    unsafe extern "C" fn(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn slurm_spank_init(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_slurmd_init(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_job_prolog(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_init_post_opt(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_local_user_init(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_user_init(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_task_init_privileged(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_task_init(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_task_post_fork(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_task_exit(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_job_epilog(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_slurmd_exit(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn slurm_spank_exit(
        spank: spank_t,
        ac: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const spank_item_S_JOB_UID: spank_item = 0;
pub const spank_item_S_JOB_GID: spank_item = 1;
pub const spank_item_S_JOB_ID: spank_item = 2;
pub const spank_item_S_JOB_STEPID: spank_item = 3;
pub const spank_item_S_JOB_NNODES: spank_item = 4;
pub const spank_item_S_JOB_NODEID: spank_item = 5;
pub const spank_item_S_JOB_LOCAL_TASK_COUNT: spank_item = 6;
pub const spank_item_S_JOB_TOTAL_TASK_COUNT: spank_item = 7;
pub const spank_item_S_JOB_NCPUS: spank_item = 8;
pub const spank_item_S_JOB_ARGV: spank_item = 9;
pub const spank_item_S_JOB_ENV: spank_item = 10;
pub const spank_item_S_TASK_ID: spank_item = 11;
pub const spank_item_S_TASK_GLOBAL_ID: spank_item = 12;
pub const spank_item_S_TASK_EXIT_STATUS: spank_item = 13;
pub const spank_item_S_TASK_PID: spank_item = 14;
pub const spank_item_S_JOB_PID_TO_GLOBAL_ID: spank_item = 15;
pub const spank_item_S_JOB_PID_TO_LOCAL_ID: spank_item = 16;
pub const spank_item_S_JOB_LOCAL_TO_GLOBAL_ID: spank_item = 17;
pub const spank_item_S_JOB_GLOBAL_TO_LOCAL_ID: spank_item = 18;
pub const spank_item_S_JOB_SUPPLEMENTARY_GIDS: spank_item = 19;
pub const spank_item_S_SLURM_VERSION: spank_item = 20;
pub const spank_item_S_SLURM_VERSION_MAJOR: spank_item = 21;
pub const spank_item_S_SLURM_VERSION_MINOR: spank_item = 22;
pub const spank_item_S_SLURM_VERSION_MICRO: spank_item = 23;
pub const spank_item_S_STEP_CPUS_PER_TASK: spank_item = 24;
pub const spank_item_S_JOB_ALLOC_CORES: spank_item = 25;
pub const spank_item_S_JOB_ALLOC_MEM: spank_item = 26;
pub const spank_item_S_STEP_ALLOC_CORES: spank_item = 27;
pub const spank_item_S_STEP_ALLOC_MEM: spank_item = 28;
pub const spank_item_S_SLURM_RESTART_COUNT: spank_item = 29;
pub const spank_item_S_JOB_ARRAY_ID: spank_item = 30;
pub const spank_item_S_JOB_ARRAY_TASK_ID: spank_item = 31;
pub type spank_item = ::std::os::raw::c_uint;
pub use self::spank_item as spank_item_t;
pub const spank_err_ESPANK_SUCCESS: spank_err = 0;
pub const spank_err_ESPANK_ERROR: spank_err = 1;
pub const spank_err_ESPANK_BAD_ARG: spank_err = 2;
pub const spank_err_ESPANK_NOT_TASK: spank_err = 3;
pub const spank_err_ESPANK_ENV_EXISTS: spank_err = 4;
pub const spank_err_ESPANK_ENV_NOEXIST: spank_err = 5;
pub const spank_err_ESPANK_NOSPACE: spank_err = 6;
pub const spank_err_ESPANK_NOT_REMOTE: spank_err = 7;
pub const spank_err_ESPANK_NOEXIST: spank_err = 8;
pub const spank_err_ESPANK_NOT_EXECD: spank_err = 9;
pub const spank_err_ESPANK_NOT_AVAIL: spank_err = 10;
pub const spank_err_ESPANK_NOT_LOCAL: spank_err = 11;
pub type spank_err = ::std::os::raw::c_uint;
pub use self::spank_err as spank_err_t;
pub const spank_context_S_CTX_ERROR: spank_context = 0;
pub const spank_context_S_CTX_LOCAL: spank_context = 1;
pub const spank_context_S_CTX_REMOTE: spank_context = 2;
pub const spank_context_S_CTX_ALLOCATOR: spank_context = 3;
pub const spank_context_S_CTX_SLURMD: spank_context = 4;
pub const spank_context_S_CTX_JOB_SCRIPT: spank_context = 5;
pub type spank_context = ::std::os::raw::c_uint;
pub use self::spank_context as spank_context_t;
pub type spank_opt_cb_f = ::std::option::Option<
    unsafe extern "C" fn(
        val: ::std::os::raw::c_int,
        optarg: *const ::std::os::raw::c_char,
        remote: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spank_option {
    pub name: *mut ::std::os::raw::c_char,
    pub arginfo: *mut ::std::os::raw::c_char,
    pub usage: *mut ::std::os::raw::c_char,
    pub has_arg: ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
    pub cb: spank_opt_cb_f,
}
#[test]
fn bindgen_test_layout_spank_option() {
    assert_eq!(
        ::std::mem::size_of::<spank_option>(),
        40usize,
        concat!("Size of: ", stringify!(spank_option))
    );
    assert_eq!(
        ::std::mem::align_of::<spank_option>(),
        8usize,
        concat!("Alignment of ", stringify!(spank_option))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).arginfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(arginfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).usage as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).has_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(has_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).val as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spank_option>())).cb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(spank_option),
            "::",
            stringify!(cb)
        )
    );
}
extern "C" {
    pub static mut spank_options: [spank_option; 0usize];
}
extern "C" {
    pub fn spank_strerror(err: spank_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn spank_symbol_supported(symbol: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spank_remote(spank: spank_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spank_context() -> spank_context_t;
}
extern "C" {
    pub fn spank_option_register(spank: spank_t, opt: *mut spank_option) -> spank_err_t;
}
extern "C" {
    pub fn spank_option_getopt(
        spank: spank_t,
        opt: *mut spank_option,
        optarg: *mut *mut ::std::os::raw::c_char,
    ) -> spank_err_t;
}
extern "C" {
    pub fn spank_get_item(spank: spank_t, item: spank_item_t, ...) -> spank_err_t;
}
extern "C" {
    pub fn spank_getenv(
        spank: spank_t,
        var: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> spank_err_t;
}
extern "C" {
    pub fn spank_setenv(
        spank: spank_t,
        var: *const ::std::os::raw::c_char,
        val: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> spank_err_t;
}
extern "C" {
    pub fn spank_unsetenv(spank: spank_t, var: *const ::std::os::raw::c_char) -> spank_err_t;
}
extern "C" {
    pub fn spank_job_control_setenv(
        sp: spank_t,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        overwrite: ::std::os::raw::c_int,
    ) -> spank_err_t;
}
extern "C" {
    pub fn spank_job_control_getenv(
        sp: spank_t,
        name: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> spank_err_t;
}
extern "C" {
    pub fn spank_job_control_unsetenv(
        sp: spank_t,
        name: *const ::std::os::raw::c_char,
    ) -> spank_err_t;
}
extern "C" {
    pub fn slurm_info(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn slurm_error(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn slurm_verbose(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn slurm_debug(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn slurm_debug2(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn slurm_debug3(format: *const ::std::os::raw::c_char, ...);
}
